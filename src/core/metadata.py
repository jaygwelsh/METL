# src/core/metadata.py

import json
import hashlib
import os
from utils.logger import get_logger
from core.cryptography import sign_data, verify_signature, generate_key_pair, serialize_private_key, serialize_public_key
from core.ai import AIPolicyRecommender

logger = get_logger(__name__)

class MetadataEngine:
    """
    The MetadataEngine handles embedding and verifying metadata
    in files via sidecar JSON files. It also provides methods for
    key loading/generation, metadata suggestion, and ledger logging
    if a ledger is provided.
    """

    def __init__(self, private_key=None, public_key=None, ledger=None, ai_config=None):
        self._private_key = private_key
        self._public_key = public_key
        self.ledger = ledger
        self.ai_recommender = AIPolicyRecommender(ai_config or {"enabled": True})

    def embed_metadata(self, file_path, metadata_dict, private_key):
        """
        Embed metadata into a sidecar JSON file. The metadata is signed
        to ensure integrity.
        """
        file_hash = self._compute_file_hash(file_path)
        metadata_dict["file_hash"] = file_hash
        signed_metadata = self._sign_metadata(metadata_dict, private_key)

        sidecar_path = self._get_sidecar_path(file_path)
        with open(sidecar_path, "w") as f:
            json.dump(signed_metadata, f, sort_keys=True)

        if self.ledger:
            self.log_to_ledger(f"Embedded metadata into {file_path}")

        return signed_metadata

    def verify_metadata(self, file_path, public_key):
        """
        Verify the metadata sidecar file against the file's hash and signature.
        """
        sidecar_path = self._get_sidecar_path(file_path)
        if not os.path.exists(sidecar_path):
            logger.error("Sidecar metadata file not found.")
            return False

        with open(sidecar_path, "r") as f:
            extracted_metadata = json.load(f)

        file_hash = self._compute_file_hash(file_path)
        if file_hash != extracted_metadata.get("file_hash"):
            logger.error("File hash does not match metadata hash.")
            return False

        signature = extracted_metadata.pop("signature", None)
        if not signature:
            logger.error("No signature found in metadata.")
            return False

        metadata_json = json.dumps(extracted_metadata, sort_keys=True)
        verified = verify_signature(metadata_json, signature, public_key)
        if verified:
            logger.info("Metadata signature verified successfully.")
        else:
            logger.error("Metadata signature verification failed.")
            logger.debug(f"Failed metadata: {metadata_json}")
            logger.debug(f"Signature: {signature}")
        return verified

    def suggest_metadata(self, content):
        """
        Suggest metadata tags based on content via AI policy recommender.
        """
        return self.ai_recommender.suggest_metadata(content)

    def load_private_key(self, key_path="private_key.pem"):
        """
        Load the private key from a PEM file if it exists. Otherwise, generate one.
        """
        if os.path.exists(key_path):
            with open(key_path, "rb") as f:
                from cryptography.hazmat.primitives import serialization
                self._private_key = serialization.load_pem_private_key(f.read(), password=None)
        else:
            self._private_key, self._public_key = generate_key_pair()
            self.save_keys("private_key.pem", "public_key.pem")
        return self._private_key

    def load_public_key(self, key_path="public_key.pem"):
        """
        Load the public key from a PEM file if it exists. If keys were generated by load_private_key,
        this should already exist.
        """
        if os.path.exists(key_path):
            with open(key_path, "rb") as f:
                from cryptography.hazmat.primitives import serialization
                self._public_key = serialization.load_pem_public_key(f.read())
        elif not self._public_key:
            # If public key doesn't exist and not generated, generate a pair now.
            self._private_key, self._public_key = generate_key_pair()
            self.save_keys("private_key.pem", "public_key.pem")
        return self._public_key

    def save_keys(self, private_key_path, public_key_path):
        """
        Save the current private and public keys to PEM files.
        """
        if self._private_key and self._public_key:
            with open(private_key_path, "wb") as f:
                f.write(serialize_private_key(self._private_key))
            with open(public_key_path, "wb") as f:
                f.write(serialize_public_key(self._public_key))

    def log_to_ledger(self, data):
        """
        Record a transaction in the ledger if available.
        """
        if self.ledger:
            self.ledger.record_transaction(data)

    def _compute_file_hash(self, file_path):
        sha256 = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(16384), b""):
                sha256.update(chunk)
        return sha256.hexdigest()

    def _sign_metadata(self, metadata_dict, private_key):
        metadata_json = json.dumps(metadata_dict, sort_keys=True)
        signature = sign_data(metadata_json, private_key)
        metadata_dict["signature"] = signature
        return metadata_dict

    def _get_sidecar_path(self, file_path):
        return f"{file_path}.metl.json"